package com.materialcentral.scan.file

import com.materialcentral.DataStringsTable
import org.geezer.db.FilteredUpdateStatement
import org.geezer.db.schema.referencesWithStandardNameAndIndex
import com.materialcentral.oss.OssPackageReleasesTable
import com.materialcentral.vulnerability.KnownVulnerabilitiesTable
import org.jetbrains.exposed.sql.ReferenceOption
import org.jetbrains.exposed.sql.ResultRow

object KnownVulnerabilityScanFindingsTable : FileScanFindingsTable<KnownVulnerabilityScanFinding>("vulnerability_repository_scan_findings") {

    val knownVulnerabilityId = long("known_vulnerability_id").referencesWithStandardNameAndIndex(KnownVulnerabilitiesTable.id, ReferenceOption.CASCADE)

    val ossPackageReleaseId = long("oss_package_release_id").referencesWithStandardNameAndIndex(OssPackageReleasesTable.id, ReferenceOption.CASCADE)

    val filePathId = long("file_path_id").referencesWithStandardNameAndIndex(DataStringsTable.id, ReferenceOption.NO_ACTION).nullable()

    override fun mapRepositoryFinding(knownVulnerabilityFinding: KnownVulnerabilityScanFinding, statement: FilteredUpdateStatement, insert: Boolean) {
        statement[knownVulnerabilityId] = knownVulnerabilityFinding.knownVulnerabilityId
        statement[ossPackageReleaseId] = knownVulnerabilityFinding.ossPackageReleaseId
        statement[filePathId] = knownVulnerabilityFinding.filePathId
    }

    override fun constructData(row: ResultRow): KnownVulnerabilityScanFinding {
        return KnownVulnerabilityScanFinding(row[knownVulnerabilityId], row[ossPackageReleaseId], row[filePathId], row[inheritedFinding], row[scanId], row[analyzerFamilyIds],
            row[analyzeFindingSeverities]?.data ?: mapOf(), row[findingFilterId])
    }


}