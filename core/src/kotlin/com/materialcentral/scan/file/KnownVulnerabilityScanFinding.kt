package com.materialcentral.scan.file

import arrow.core.Either
import arrow.core.NonEmptyList
import arrow.core.left
import arrow.core.right
import com.materialcentral.DataStringsTable
import org.geezer.db.db
import com.materialcentral.oss.OssPackageCoordinates
import com.materialcentral.oss.OssPackageReleasesTable
import com.materialcentral.scan.filter.ScanFindingFilter
import com.materialcentral.scan.FindingType
import com.materialcentral.scan.FindingSeverity
import com.materialcentral.scan.Scan
import com.materialcentral.scan.file.analysis.KnownVulnerabilityAnalysisFinding
import com.materialcentral.vulnerability.*
import com.materialcentral.vulnerability.cvss.CvssVersion

class KnownVulnerabilityScanFinding(
    val knownVulnerabilityId: Long,
    val ossPackageReleaseId: Long,
    override val filePathId: Long?,
    inheritedFinding: Boolean,
    scanId: Long,
    analyzerIds: List<String>,
    analyzerSeverities: Map<String, FindingSeverity>,
    filterId: Long?
) : FileScanFinding(inheritedFinding, scanId, analyzerIds, analyzerSeverities, filterId) {

    override val type: FindingType = FindingType.KNOWN_VULNERABILITY

    override val filterFindingTypes: Set<FindingType> = setOf(FindingType.KNOWN_VULNERABILITY, FindingType.OSS_PACKAGE_RELEASE)

    override fun lookupSeverity(): FindingSeverity? {
        return db {
            val knownVulnerability = KnownVulnerabilitiesTable.getById(knownVulnerabilityId)
            val bestCvssV3Score = knownVulnerability.bestCvssV3Score
            if (bestCvssV3Score != null) {
                CvssVersion.V3.scoreToSeverity(bestCvssV3Score).findingSeverity
            } else {
                null
            }
        }
    }

    override fun detailsMatchFilter(filter: ScanFindingFilter): Boolean {
        return when (filter.findingType) {
            FindingType.KNOWN_VULNERABILITY -> {

                if (filter.findingPrimaryIdentifierRegexs.isNotEmpty()) {
                    val identifiers = KnownVulnerabilityIdentifiersTable.findKnownVulnerabilityIdentifiers(knownVulnerabilityId).map { it.identifier }
                    if (filter.findingPrimaryIdentifierRegexs.none { regex -> identifiers.any { regex.matches(it) } }) {
                        return false
                    }
                }

                if (filter.findingSecondaryIdentifierRegexs.isNotEmpty()) {
                    val coordinates = OssPackageCoordinates.findById(ossPackageReleaseId)
                    if (coordinates != null && filter.findingSecondaryIdentifierRegexs.none { it.matches(coordinates.purl) }) {
                        return false
                    }
                }

                true
            }

            FindingType.OSS_PACKAGE_RELEASE -> {
                
                if (filter.findingPrimaryIdentifierRegexs.isNotEmpty()) {
                    val coordinates = OssPackageCoordinates.findById(ossPackageReleaseId)
                    if (coordinates != null && filter.findingPrimaryIdentifierRegexs.none { it.matches(coordinates.purl) }) {
                        return false
                    }
                }

                true
            }

            else -> {
                false
            }
        }

    }

    companion object {
        fun create(scan: Scan, analysisFindings: NonEmptyList<KnownVulnerabilityAnalysisFinding>): Either<String, KnownVulnerabilityScanFinding> {
            val (analyzerIds, analyzerSeverities) = getIdsAndSeverities(analysisFindings)
            val finding = analysisFindings.head
            val vulnerabilityIdentifiers = analysisFindings.flatMap { it.vulnerabilityIdentifiers }
            var primaryIdentifier = vulnerabilityIdentifiers.firstOrNull { it.toKnownVulnerabilityIdentifierType() == KnownVulnerabilityIdentifierType.CVE }
            if (primaryIdentifier == null) {
                primaryIdentifier = vulnerabilityIdentifiers.firstOrNull { it.toKnownVulnerabilityIdentifierType() != null }
            }

            if (primaryIdentifier == null) {
                return "Unable to find valid known vulnerability identifier from analysis finding identifiers ${vulnerabilityIdentifiers.joinToString(", ")}".left()
            }

            val knownVulnerability = KnownVulnerabilitySynchronizer.findOrCreate(primaryIdentifier)
            if (knownVulnerability == null) {
                return "Unable to find known vulnerability with identifier $primaryIdentifier".left()
            }

            val ossPackageRelease = OssPackageReleasesTable.findOrCreate(finding.packageType, finding.packageName, finding.packageVersion)
            val filePath = analysisFindings.filter { !it.filePath.isNullOrBlank() }.firstOrNull()?.filePath
            val filePathId = filePath?.let { filePath -> if (filePath.isNullOrBlank()) null else DataStringsTable.getOrCreate(filePath) }
            val inheritedFinding = analysisFindings.any { it.inheritedFinding }

            return KnownVulnerabilityScanFindingsTable.create(KnownVulnerabilityScanFinding(knownVulnerability.id, ossPackageRelease.id, filePathId, inheritedFinding, scan.id, analyzerIds, analyzerSeverities, null)).right()
        }
    }
}