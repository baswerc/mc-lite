package com.materialcentral.vulnerability.cvss

import org.geezer.db.FilteredUpdateStatement
import org.geezer.db.schema.DataTable
import org.geezer.db.schema.enum
import com.materialcentral.vulnerability.KnownVulnerabilitiesTable
import com.materialcentral.vulnerability.KnownVulnerabilityAnalyzerSource
import com.materialcentral.vulnerability.db.KnownVulnerabilityDB
import org.jetbrains.exposed.sql.ReferenceOption
import org.jetbrains.exposed.sql.ResultRow

object CvssScoresTable : DataTable<CvssScore>("cvss_scores") {
    val vulnerabilityId = long("vulnerability_id").references(KnownVulnerabilitiesTable.id, onDelete = ReferenceOption.CASCADE).index("cvss_scores_vulnerability_ix")

    val db = enum("db_id", KnownVulnerabilityDB)

    val severity = enum("severity_id", CvssSeverity)

    val cna = varchar("cna", 50)

    val version = enum("version_id", CvssVersion)

    val baseScore = double("base_score")

    val vector = varchar("vector", 128)

    init {
        index("cvss_scores_uq", isUnique = true, vulnerabilityId, db, cna, version)
    }

    override fun mapDataToStatement(score: CvssScore, statement: FilteredUpdateStatement, insert: Boolean) {
        if (insert) {
            statement[vulnerabilityId] = score.vulnerabilityId
            statement[db] = score.db
            statement[cna] = score.cna
            statement[version] = score.version
        }

        statement[severity] = score.severity
        statement[baseScore] = score.baseScore
        statement[vector] = score.vector
    }

    override fun constructData(row: ResultRow): CvssScore {
        return CvssScore(row[vulnerabilityId], row[db], row[cna], row[version], row[severity], row[baseScore], row[vector])
    }
}