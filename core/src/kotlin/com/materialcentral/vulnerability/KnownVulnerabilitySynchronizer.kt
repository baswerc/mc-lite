package com.materialcentral.vulnerability

import arrow.core.Either
import org.geezer.db.db
import org.geezer.system.runtime.RuntimeClock
import com.materialcentral.vulnerability.cvss.CvssScore
import com.materialcentral.vulnerability.cvss.CvssScoresTable
import com.materialcentral.vulnerability.cvss.CvssVersion
import com.materialcentral.vulnerability.db.KnownVulnerabilityDB
import com.materialcentral.vulnerability.db.isTop
import com.materialcentral.vulnerability.db.nvd.NvdClient
import org.jetbrains.exposed.sql.and
import org.slf4j.Logger
import org.slf4j.LoggerFactory

object KnownVulnerabilitySynchronizer {
    private val log: Logger = LoggerFactory.getLogger(javaClass)

    fun findOrCreate(primaryIdentifier: String): KnownVulnerability? {
        var knownVulnerability = KnownVulnerabilitiesTable.find(primaryIdentifier)
        return if (knownVulnerability != null) {
            knownVulnerability
        } else {
            try {
                knownVulnerability = KnownVulnerabilitiesTable.create(KnownVulnerability(primaryIdentifier))
                synchronize(knownVulnerability)
                knownVulnerability
            } catch (e: Exception) {
                KnownVulnerabilitiesTable.find(primaryIdentifier) ?: throw e
            }
        }
    }

    fun synchronize(knownVulnerability: KnownVulnerability) {

        db {
            if (knownVulnerability.primaryIdentifier.isCve) {
                synchronizeWithNVD(knownVulnerability)
            }

            val scores = CvssScoresTable.findWhere { (CvssScoresTable.vulnerabilityId eq knownVulnerability.id) }

            val v3Scores = scores.filter { it.version == CvssVersion.V3 }.distinctBy { it.cna }
            if (v3Scores.isNotEmpty()) {
                val averageScore = v3Scores.map { it.baseScore }.average()
                knownVulnerability.averageCvssV3Score = averageScore
                knownVulnerability.bestCvssV3Score = averageScore // TODO Implement preferred scoring
            }


            knownVulnerability.lastSynchronizedAt = RuntimeClock.now
            KnownVulnerabilitiesTable.update(knownVulnerability)
        }
    }

    fun synchronizeWithNVD(knownVulnerability: KnownVulnerability) {
        when (val result = NvdClient.getCve(knownVulnerability.primaryIdentifier)) {
            is Either.Left -> {
                log.warn("Unable to synchronize known vulnerability: $knownVulnerability with NVD due to: ${result.value}")
            }

            is Either.Right -> {
                val cve = result.value

                if (cve == null) {
                    return
                }

                if (!knownVulnerability.dbs.contains(KnownVulnerabilityDB.NVD)) {
                    knownVulnerability.addDb(KnownVulnerabilityDB.NVD)
                }

                val isTopDB = knownVulnerability.dbs.isTop(KnownVulnerabilityDB.NVD)

                if (!cve.description.isNullOrBlank() && (knownVulnerability.description.isNullOrBlank() || isTopDB)) {
                    knownVulnerability.description = cve.description
                }

                if (cve.publishedAt != null && (knownVulnerability.publishedAt == null || isTopDB)) {
                    knownVulnerability.publishedAt = cve.publishedAt
                }

                if (cve.lastModifiedAt != null && (knownVulnerability.lastModifiedAt == null || isTopDB)) {
                    knownVulnerability.lastModifiedAt = cve.lastModifiedAt
                }

                val existingScores = CvssScoresTable.findWhere { (CvssScoresTable.vulnerabilityId eq knownVulnerability.id) and (CvssScoresTable.db eq KnownVulnerabilityDB.NVD) }

                for (nvdScore in cve.scores) {
                    val existingScore = existingScores.firstOrNull { it.version == nvdScore.version && it.cna == nvdScore.source }
                    if (existingScore == null) {
                        log.info("Creating CVSS score: ${nvdScore.source}:${nvdScore.version}:${nvdScore.baseScore} from NVD for known vulnerability: $knownVulnerability")
                        CvssScoresTable.createIgnoreDuplicate(CvssScore(knownVulnerability.id, KnownVulnerabilityDB.NVD, nvdScore.source, nvdScore.version, nvdScore.severity, nvdScore.baseScore, nvdScore.vector))
                    } else if (existingScore.severity != nvdScore.severity || existingScore.baseScore != nvdScore.baseScore || existingScore.vector != nvdScore.vector) {
                        log.info("Updating CVSS score $existingScores for known vulnerability: $knownVulnerability")
                        existingScore.severity = nvdScore.severity
                        existingScore.baseScore = nvdScore.baseScore
                        existingScore.vector = nvdScore.vector
                        CvssScoresTable.update(existingScore, CvssScoresTable.severity, CvssScoresTable.baseScore, CvssScoresTable.vector)
                    }
                }

                for (existingScore in existingScores) {
                    if (cve.scores.none { it.source == existingScore.cna && it.version == existingScore.version }) {
                        log.info("Deleting CVSS score $existingScores for known vulnerability: $knownVulnerability")
                        CvssScoresTable.delete(existingScore)
                    }
                }
            }
        }
    }
}