package com.materialcentral.vulnerability

import org.geezer.db.FilteredUpdateStatement
import org.geezer.db.schema.DataTable
import org.geezer.db.schema.enum
import org.geezer.db.schema.eqIgnoreCase
import org.geezer.db.schema.uniqueIndexWithStandardName
import org.jetbrains.exposed.sql.ReferenceOption
import org.jetbrains.exposed.sql.ResultRow
import org.jetbrains.exposed.sql.select

object KnownVulnerabilityIdentifiersTable : DataTable<KnownVulnerabilityIdentifier>("known_vulnerability_identifiers") {
    const val IdentifierLength = 100

    val knownVulnerabilityId = long("known_vulnerability_id").references(KnownVulnerabilitiesTable.id, onDelete = ReferenceOption.CASCADE).index("vulnerability_identifiers_vulnerability_ix")

    val identifier = varchar("identifier", IdentifierLength).uniqueIndexWithStandardName()

    val type = enum("type_id", KnownVulnerabilityIdentifierType).nullable()

    fun createIfNecessary(knownVulnerabilityId: Long, identifier: String, type: KnownVulnerabilityIdentifierType? = identifier.toKnownVulnerabilityIdentifierType()) {
        val find = { select { KnownVulnerabilityIdentifiersTable.identifier eqIgnoreCase identifier }.singleOrNull()?.let(::constructData)}
        var kvi = find()
        if (kvi == null) {
            kvi = try {
                create(KnownVulnerabilityIdentifier(knownVulnerabilityId, identifier, type))
            } catch (e: Exception) {
                find() ?: throw e
            }
        }

        if (kvi?.knownVulnerabilityId != knownVulnerabilityId) {
            throw IllegalStateException("Known vulnerability identifier $identifier is already assigned to known vulnerability id: ${kvi?.knownVulnerabilityId} and cannot also be assigned to known vulnerability id: $knownVulnerabilityId")
        }
    }

    fun findKnownVulnerabilityIdentifiers(knownVulnerabilityId: Long): List<KnownVulnerabilityIdentifier> {
        return KnownVulnerabilityIdentifiersTable.findWhere { KnownVulnerabilityIdentifiersTable.knownVulnerabilityId eq knownVulnerabilityId }
    }

    override fun mapDataToStatement(data: KnownVulnerabilityIdentifier, statement: FilteredUpdateStatement, insert: Boolean) {
        if (insert) {
            statement[knownVulnerabilityId] = data.knownVulnerabilityId
            statement[identifier] = data.identifier
        }
        statement[type] = data.type
    }

    override fun constructData(row: ResultRow): KnownVulnerabilityIdentifier {
        return KnownVulnerabilityIdentifier(row[knownVulnerabilityId], row[identifier], row[type]).apply { linkToDB(row[KnownVulnerabilityIdentifiersTable.id]) }
    }
}