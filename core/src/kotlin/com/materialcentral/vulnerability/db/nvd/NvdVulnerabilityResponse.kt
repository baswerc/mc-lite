package com.materialcentral.vulnerability.db.nvd

import arrow.core.Either
import arrow.core.left
import arrow.core.right
import com.beust.klaxon.JsonObject
import org.geezer.flexInt
import org.slf4j.Logger
import org.slf4j.LoggerFactory

class NvdVulnerabilityResponse(val resultsPerPage: Int, val startIndex: Int, val totalResults: Int, val cves: List<NvdCve>) {
    companion object {
        val log: Logger = LoggerFactory.getLogger(javaClass)

        fun map(json: JsonObject): Either<String, NvdVulnerabilityResponse> {
            val resultsPerPage = json.flexInt("resultsPerPage") ?: return "Missing resultsPerPage property.".left()

            val startIndex = json.flexInt("startIndex") ?: return "Missing startIndex property.".left()

            val totalResults = json.flexInt("totalResults") ?: return "Missing totalResults property.".left()

            val cves = mutableListOf<NvdCve>()
            val vulnerabilities = json.array<JsonObject>("vulnerabilities")
            if (vulnerabilities != null) {
                for (vulnerability in vulnerabilities) {
                    val cve = vulnerability.obj("cve")
                    if (cve == null) {
                        log.warn("NVD vulnerability object: ${vulnerability.toJsonString()} without cve property.")
                        continue
                    }

                    when (val result = NvdCve.map(cve)) {
                        is Either.Left -> {
                            log.warn("Unable to map NVD CVE JSON: ${vulnerability.toJsonString()} due to: ${result.value}")
                        }

                        is Either.Right -> {
                            cves.add(result.value)
                        }
                    }
                }
            }

            return NvdVulnerabilityResponse(resultsPerPage, startIndex, totalResults, cves).right()
        }
    }
}
