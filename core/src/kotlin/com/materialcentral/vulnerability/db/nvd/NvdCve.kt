package com.materialcentral.vulnerability.db.nvd

import arrow.core.Either
import arrow.core.left
import arrow.core.right
import com.beust.klaxon.JsonObject
import org.geezer.nonEmptyString
import com.materialcentral.vulnerability.cvss.CvssVersion
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import java.text.SimpleDateFormat
import java.util.*

class NvdCve(val id: String, val publishedAt: Long?, val lastModifiedAt: Long?, val description: String?, val scores: List<NvdCvssScore>, val references: List<NvdReference>) {
    companion object {
        private val log: Logger = LoggerFactory.getLogger(javaClass)

        fun map(json: JsonObject): Either<String, NvdCve> {
            val id = json.nonEmptyString("id") ?: return "Missing id property.".left()

            val publishedAt = parseTimestamp(json.string("published"))
            val lastModifiedAt = parseTimestamp(json.string("lastModified"))
            val description = json.array<JsonObject>("descriptions")?.firstOrNull { it.string("lang") == "en" }?.string("value")

            val metrics = json.obj("metrics")
            val scores = mutableListOf<NvdCvssScore>()
            if (metrics != null) {
                for (property in metrics.keys) {
                    val version = if (property.startsWith("cvssMetricV3", true)) {
                        CvssVersion.V3
                    } else if (property.startsWith("cvssMetricV2", true)) {
                        CvssVersion.V2
                    } else {
                        log.info("Unsupported NVD metrics property: $property")
                        null
                    }

                    if (version != null) {
                        val scoreData = metrics.array<JsonObject>(property)
                        if (scoreData != null) {
                            for (scoreDatum in scoreData) {
                                when (val result = NvdCvssScore.map(version, scoreDatum)) {
                                    is Either.Left -> {
                                        log.warn("Unable to parse NVD score metric: ${scoreData.toJsonString()} due to: ${result.value}")
                                    }

                                    is Either.Right -> {
                                        scores.add(result.value)
                                    }
                                }
                            }
                        }
                    }
                }
            }


            val references = mutableListOf<NvdReference>()
            val referenceData = json.array<JsonObject>("references")
            if (referenceData != null) {
                for (referenceDatum in referenceData) {
                    when (val result = NvdReference.map(referenceDatum)) {
                        is Either.Left -> {
                            log.warn("Unable to parse NVD reference: ${referenceData.toJsonString()} due to: ${result.value}")
                        }

                        is Either.Right -> {
                            references.add(result.value)
                        }
                    }
                }
            }


            return NvdCve(id, publishedAt, lastModifiedAt, description, scores, references).right()
        }

        fun parseTimestamp(value: String?): Long? {
            return if (value.isNullOrBlank()) {
                null
            } else {
                try {
                    SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS").apply { timeZone = TimeZone.getTimeZone("UTC") }.parse(value).time
                } catch (e: Exception) {
                    log.warn("Unable to parse NVD timestamp value $value")
                    null
                }
            }
        }
    }
}
